#!/usr/bin/env python
import numpy as np
#from subprocess import call,Popen,PIPE
from os import system
from scipy.optimize import *  
#from sys import argv

# This program performs potential parameterization by minimization of
# a chi-sq test for forces, dipoles and stresses of AI calculations
# with respect to their force-field equivalent using general optimization
# algorithms like CG, L-BFGS, Nelder-Mead. The results from this first step
# are fed into a basin hopping algorithm that will scan parameter space for a 
# possible global minimum that is better than the initial one provided to it. 
# 
# The input files are 
# PARAMS with a list of parameters, initial values, bounds and step sizes
# OPT with details about the optimization, like method, scaling factors
# TEMPLATES with the names of the template files and their corresponding potential file
# AI_FORCES, AI_STRESSES, AI_DIPOLES with the names of the files with the corresponding AI values
# COMMANDS is a shell script in charge of running the program with the potentials and parsing its 
# output. It should generate files called FF_FORCES, FF_DIPOLES, FF_STRESSES containing these values
# in the same order as specified in the AI_* files. To check that the values are not unreasonable, 
# it is good to print the number of errors generated by the ff program into a file called ERRORS, 
# This will cause the min algorithm to allocate very high objective function values to these instances.
#
# This routine reads the input files, e.g. TEMPLATES, OPT, AI_*,etc
def readFromFile(name,cols,split):
  configs = []
  cols = int(cols)
  split = bool(split)
  with open(name, "r") as f:
    for line in f.readlines():
      li = line.strip()
      if not li.startswith("#"):
	if cols == 1:
	  if split == True:
	    configs.append(line.split())
	  else:
	    configs.append([line])
	if cols == 2:
	  configs.append(line.split())
	if cols == 3:
	  configs.append(line.split())
	if cols == 6:
	  configs.append(line.split())
  return configs

# this routine replaces the parameter labels in the templates by the
# values specified in PARAMS and saves the result to a potential file
# specified in TEMPLATES
def replaceValues(source,target,variables,values):
  with open(source, "r") as oldfile, open(target, "w") as new_file:
    for line in oldfile:
      for i in range(len(variables)):
	line = line.replace(variables[i],fmt.format(values[i]))
      new_file.write(line)

# calculation of the chi sq
def chiSq(ai_vals,ff_vals):
  sqDiff = [] 
  denom = []
  for i in range(np.shape(ai_vals)[-1]):  
    for j,k in zip(ai_vals,ff_vals):
      sqDiff.append((k[i]-j[i])**2)
      denom.append((j[i]**2))
  sqDiff = np.array(sqDiff)
  denom = np.array(denom)
  sqDiff = np.reshape(sqDiff,(np.shape(ai_vals)[-1],np.shape(ai_vals)[0]))
  denom = np.reshape(denom,(np.shape(ai_vals)[-1],np.shape(ai_vals)[0]))
  chiSq = []
  for i in range(np.shape(ai_vals)[-1]):
    chiSq.append(np.sum(sqDiff[i])/np.sum(denom[i]))
  chiSq = np.sum(np.array(chiSq))/np.shape(ai_vals)[-1]
  return chiSq

# These are the bounds for BH
class MyBounds(object):
  def __init__(self, xmax, xmin ):
      self.xmax = np.array(xmax)
      self.xmin = np.array(xmin)
  def __call__(self, **kwargs):
      x = kwargs["x_new"]
      tmax = bool(np.all(x <= self.xmax))
      tmin = bool(np.all(x >= self.xmin))
      if not tmax and tmin:
	print 'Values out of bounds!\n'
      return tmax and tmin

# Routine used to write a restart file for accepted parameter sets from BH
class WriteRestart(object):
  def __init__(self,nvars,nconst,zerosAndones,nmin,nmax,steps,filename):
    self.nvars = nvars
    self.nconst = nconst
    self.zerosAndones = zerosAndones
    self.nmax = nmax
    self.nmin = nmin
    self.steps = steps
    self.filename = str(filename)
  def __call__(self,x,f,accepted):
    if int(accepted) == 1:
      x = np.array(x)
      with open(self.filename, "w") as file:
	fmt="{0:.7f}"
	file.write('# The total chi sq is: '+fmt.format(f)+'\n')
	for lineNumber,var in enumerate(self.nvars):
	  output = str(var)+'\t'+fmt.format((np.concatenate((self.nconst,x),axis=0))[lineNumber])+'\t'+ \
	  str(self.zerosAndones[lineNumber])+'\t'+fmt.format(self.nmin[lineNumber])+'\t'+fmt.format(self.nmax[lineNumber])+'\t' + \
	  fmt.format(self.steps[lineNumber])+'\n'
	  file.write(output)

# this routine defines the magnitude of the steps in BH - these steps are defined in PARAMS
class MyTakeStep(object):
    def __init__(self, stepsizes):
        self.stepsizes = stepsizes
    def __call__(self, x):
	for i in range(len(self.stepsizes)):
	  s = self.stepsizes
	  x[i] += np.random.uniform(-s[i], s[i])
	  return x

# This is the objective function evaluated by the minimization algorithms 
class sumOfChi(object):
  def __init__(self,const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,factorF,factorD,factorS):
    self.const_vars = const_vars
    self.pot_vars = pot_vars
    self.const_values = const_values
    self.factorF = factorF
    self.factorD = factorD
    self.factorS = factorS
    # arrays with forces, dipoles and stresses
    # x = 0, y = 1, z = 2
    # xx = 0,xy = 1, yy = 2 , xz = 3, zz = 4, yz = 5
    self.ai_forces = ai_forces
    self.ai_dipoles = ai_dipoles
    self.ai_stresses = ai_stresses
  def __call__(self,test_values):
    # test_values should be an np array

    templates = readFromFile('TEMPLATES',2,True)
    for line in templates:
      replaceValues(line[0],line[1],self.const_vars+self.pot_vars,np.concatenate((self.const_values,test_values),axis=0))

    system('COMMANDS')
    with open('ERRORS', "r") as f:
      errors = int(f.readline().strip())
    if errors == 0: 
      ff_Fx,ff_Fy,ff_Fz = np.loadtxt('FF_FORCES',unpack=True)
      ff_forces = np.array([ff_Fx,ff_Fy,ff_Fz])
      ff_Dx,ff_Dy,ff_Dz = np.loadtxt('FF_DIPOLES',unpack=True)
      ff_dipoles = np.array([ff_Dx,ff_Dy,ff_Dz])
      index,ff_xx_xy,ff_yy_xz,ff_zz_yz = np.loadtxt('FF_STRESSES',unpack=True)
      ff_xx = (ff_xx_xy[0::2])
      ff_xy = (ff_xx_xy[1::2])
      ff_yy = (ff_yy_xz[0::2])
      ff_xz = (ff_yy_xz[1::2])
      ff_zz = (ff_zz_yz[0::2])
      ff_yz = (ff_zz_yz[1::2])
      ff_stresses = np.array([ff_xx,ff_xy,ff_yy,ff_xz,ff_zz,ff_yz])
      chiSqF = chiSq(self.ai_forces,ff_forces)
      chiSqD = chiSq(self.ai_dipoles,ff_dipoles)
      chiSqS = 2*chiSq(self.ai_stresses,ff_stresses)
      factorTot = self.factorF+self.factorD+self.factorS
      totalChi = (self.factorF*chiSqF+self.factorD*chiSqD+self.factorS*chiSqS)/factorTot
      print ' '
      print 'Forces chi sq: ',fmt.format(chiSqF)
      print 'Dipoles chi sq: ',fmt.format(chiSqD)
      print 'Stresses chi sq: ',fmt.format(chiSqS)
      print 'Total chi sq (no factors): ',fmt.format((chiSqF+chiSqD+chiSqS)/3.0)
      print 'Total chi sq: ',fmt.format(totalChi)
    else: 
      print 'Error: likely due to unphysical parameter value' 
      totalChi = 1E10
    return totalChi

params = readFromFile('PARAMS',6,True)
forces_files = readFromFile('AI_FORCES',2,True)
dipoles_files = readFromFile('AI_DIPOLES',2,True)
stresses_files = readFromFile('AI_STRESSES',2,True)
fmt="{0:.7f}"

ai_Fx = np.empty(0)
ai_Fy = np.empty(0)
ai_Fz = np.empty(0)
for line in forces_files:
  dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  ai_Fx = np.append(ai_Fx,dummy1[:int(line[1])])
  ai_Fy = np.append(ai_Fy,dummy2[:int(line[1])])
  ai_Fz = np.append(ai_Fz,dummy3[:int(line[1])])
ai_forces = np.array([ai_Fx,ai_Fy,ai_Fz])

ai_Dx = np.empty(0)
ai_Dy = np.empty(0)
ai_Dz = np.empty(0)
for line in dipoles_files:
  dummy0, dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  ai_Dx = np.append(ai_Dx,dummy1[:int(line[1])])
  ai_Dy = np.append(ai_Dy,dummy2[:int(line[1])])
  ai_Dz = np.append(ai_Dz,dummy3[:int(line[1])])
ai_dipoles = np.array([ai_Dx,ai_Dy,ai_Dz])

ai_xx_xy = np.empty(0)
ai_yy_xz = np.empty(0)
ai_zz_yz = np.empty(0)
for line in stresses_files:
  dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  if not int(line[1]) == 0:
    ai_xx_xy = np.append(ai_xx_xy,dummy1)
    ai_yy_xz = np.append(ai_yy_xz,dummy2)
    ai_zz_yz = np.append(ai_zz_yz,dummy3)
ai_xx = (ai_xx_xy[0::2])
ai_xy = (ai_xx_xy[1::2])
ai_yy = (ai_yy_xz[0::2])
ai_xz = (ai_yy_xz[1::2])
ai_zz = (ai_zz_yz[0::2])
ai_yz = (ai_zz_yz[1::2])
ai_stresses = np.array([ai_xx,ai_xy,ai_yy,ai_xz,ai_zz,ai_yz])


pot_vars = []
const_vars = []
#
pot_values = [] 
const_values = [] 
#
pot_values_min = [] 
pot_values_max = [] 
minim_bounds = [] 
const_pot_values_min = [] 
const_pot_values_max = [] 
#
step_sizes = []
const_step_sizes = []
to_fit_and_not0 = []
to_fit_and_not1 = []
for i in params:
  if not int(i[2]) == 0:
    pot_vars.append(i[0])
    pot_values.append(float(i[1]))
    pot_values_min.append(float(i[3]))
    pot_values_max.append(float(i[4]))
    minim_bounds.append(tuple([float(i[3]),float(i[4])]))
    step_sizes.append(float(i[5]))
    to_fit_and_not1.append(i[2])
  elif int(i[2]) == 0:
    const_vars.append(i[0])
    const_values.append(float(i[1]))
    const_pot_values_min.append(float(i[3]))
    const_pot_values_max.append(float(i[4]))
    const_step_sizes.append(float(i[5]))
    to_fit_and_not0.append(i[2])

pot_values = np.asarray(pot_values)
const_values = np.asarray(const_values)
tot_vars = const_vars+pot_vars
tot_values_min = const_pot_values_min+pot_values_min
tot_values_max = const_pot_values_max+pot_values_max
all_step_sizes = const_step_sizes+step_sizes
to_fit_and_not = to_fit_and_not0 + to_fit_and_not1

### Read parameters for the optimization routines
opt_file = readFromFile('OPT',2,True)
run_opts = {}
for i in opt_file:
  if str(i[0]) in ('method_Min','method_BH'):
    run_opts[i[0]] = i[1]
  elif i[0] == 'disp':
    run_opts[i[0]] = bool(i[1])
  elif i[0] in ('maxiter_Min','maxiter_BH','niter_success','niter_BH'):
    run_opts[i[0]] = np.int(i[1])
  else:
    run_opts[i[0]] = np.float(i[1])
factorF = run_opts['scalingF']
factorD = run_opts['scalingD']
factorS = run_opts['scalingS']
method_Min = run_opts['method_Min']
ftol_Min = run_opts['ftol_Min']
gtol_Min = run_opts['gtol_Min']
xtol_Min = run_opts['xtol_Min']
maxiter_Min = run_opts['maxiter_Min'] 
stepsize_Min = run_opts['stepsize_Min'] 
verbose = run_opts['disp'] 
tempScale = run_opts['temperature']
method_BH = run_opts['method_BH'] 
ftol_BH = run_opts['ftol_BH']
gtol_BH = run_opts['gtol_BH']
xtol_BH = run_opts['xtol_BH']
maxiter_BH = run_opts['maxiter_BH'] 
stepsize_BH = run_opts['stepsize_BH'] 
timestep = run_opts['timestep'] 
niter_BH = run_opts['niter_BH'] 
niter_success = run_opts['niter_success']

thisSumOfChi = sumOfChi(const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,factorF,factorD,factorS)
thisSumOfChi(pot_values)

# Initial minimization 
if method_Min == 'L-BFGS-B' or 'TNC' or 'SLSQP':
  bounds = minim_bounds
else:
  bounds = None
if method_Min == 'L-BFGS-B' or 'BFGS' or 'CG':
  options={'ftol': ftol_Min, 'gtol':gtol_Min,'xtol':xtol_Min,'disp': verbose,'maxiter': maxiter_Min,'eps':stepsize_Min}
else:
  options={'ftol': ftol_Min, 'gtol':gtol_Min, 'xtol':xtol_Min,'disp': verbose,'maxiter': maxiter_Min}
results_Min = minimize(thisSumOfChi,pot_values,method=method_Min,bounds=bounds,
              options=options)
print results_Min.message
tot_values = np.concatenate((const_values,results_Min.x),axis=0)

# Write a results file 
write_Results_Min = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESULTS_Min')
write_Results_Min(results_Min.x,results_Min.fun,accepted=1)
########################################################################################
# basin hopping part using the minimization parameters as a starting guess             #
# The temperature should be a fraction of the final function value from the minimizer  #
########################################################################################
# Define variables for BH RESTART file 
write_restart = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESTART')
#
mysteps = MyTakeStep(step_sizes) 
temperature = results_Min.fun*tempScale
print 'The temperature is set to: ', temperature
mybounds = MyBounds(pot_values_max,pot_values_min)
if method_BH in ('L-BFGS-B', 'TNC','SLSQP'):
  bounds = minim_bounds
else:
  bounds = None
# Pass the optimized values to BH
pot_values = results_Min.x
#
if method_BH in ('L-BFGS-B','BFGS','CG'):
  options={'ftol': ftol_BH, 'gtol':gtol_BH, 'xtol':xtol_BH,'disp': verbose,'maxiter': maxiter_BH,'eps':stepsize_BH}
else:
  options={'ftol': ftol_BH, 'gtol':gtol_BH , 'xtol':xtol_BH,'disp': verbose,'maxiter': maxiter_BH}
minimizer_kwargs = {'method': method_BH,'bounds':bounds,'options':options}

results_BH = basinhopping(thisSumOfChi,pot_values,T=temperature,stepsize=timestep,take_step=mysteps,
	  minimizer_kwargs=minimizer_kwargs,
	  disp=verbose,accept_test=mybounds,
	  niter=niter_BH,callback=write_restart,niter_success=niter_success)
print results_BH.message
tot_values = np.concatenate((const_values,results_BH.x),axis=0)
#
## Write a results file for the BH part 
write_Results_BH = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESULTS_BH')
write_Results_BH(results_BH.x,results_BH.fun,accepted=1)
