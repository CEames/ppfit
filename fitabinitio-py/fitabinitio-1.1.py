#!/usr/bin/env python
import numpy as np
import os,errno,sys
import shutil,glob
from scipy.optimize import *  
import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
from matplotlib.backends.backend_pdf import PdfPages

"""
This program performs potential parameterization by minimization of
a chi-sq test for forces, dipoles and stresses of AI calculations
with respect to their force-field equivalent using general optimization
algorithms like CG, L-BFGS, Nelder-Mead. The results from this step
can be fed into a basin hopping algorithm that will scan parameter space for a 
possible global minimum that is better than the initial one provided to it. 

The input files are 
PARAMS with a list of parameters, initial values, bounds and step sizes
OPT with details about the optimization, like method, scaling factors
TEMPLATES with the names of the template files and their corresponding potential file
AI_FORCES_files, AI_STRESSES_files, AI_DIPOLES_files with the names of the files with the corresponding AI values
COMMANDS is a shell script in charge of running the program with the potentials and parsing its 
output. It should generate files called FF_FORCES, FF_DIPOLES, FF_STRESSES containing these values
in the same order as specified in the AI_* files. To check that the values are not unreasonable, 
it is good to print the number of errors generated by the ff program into a file called ERRORS, 
This will cause the min algorithm to allocate very high objective function values to these instances.

"""
# This routine reads the input files, e.g. TEMPLATES, OPT, AI_*,etc
def readFromFile(name,cols,split):
  configs = []
  cols = int(cols)
  split = bool(split)
  with open(name, "r") as f:
    for line in f.readlines():
      li = line.strip()
      if not li.startswith("#"):
	if cols == 1:
	  if split == True:
	    configs.append(line.split())
	  else:
	    configs.append([line])
	if cols == 2:
	  configs.append(line.split())
	if cols == 3:
	  configs.append(line.split())
	if cols == 6:
	  configs.append(line.split())
  return configs

# this routine replaces the parameter labels in the templates by the
# values specified in PARAMS and saves the result to a potential file
# specified in TEMPLATES
def replaceValues(source,target,variables,values):
  with open(source, "r") as oldfile, open(target, "w") as new_file:
    for line in oldfile:
      for i in range(len(variables)):
	line = line.replace(variables[i],fmt.format(values[i]))
      new_file.write(line)

# calculation of the chi sq
def chiSq(ai_vals,ff_vals,ai_s2,genplot,filename):
  genplot = bool(genplot)
  sqDiff = [] 
  ai_plot = []
  ff_plot = []
  for i in range(np.shape(ai_vals)[-1]):  
    numerator = 0.0
    denominator = 0.0
    ai_val = 0.0
    ff_val = 0.0
    for j,k,l in zip(ai_vals,ff_vals,ai_s2):
      if np.shape(ai_vals)[0] < 4:
	numerator += ((k[i]-j[i])**2)
	denominator += l 
      else:
	numerator += ((k[i]-j[i])**2)
	denominator += (j[i])**2
      if genplot:
	ai_val += (j[i])**2
	ff_val += (k[i])**2
    sqDiff.append(numerator/denominator)
    if genplot:
      ai_plot.append(ai_val)
      ff_plot.append(ff_val)
  sqDiff = np.array(sqDiff)
  if genplot:
    ai_plot = np.sqrt(ai_plot)
    ff_plot = np.sqrt(ff_plot)
  chiSq = np.sum(sqDiff)/len(sqDiff)
  if genplot:
    with PdfPages(filename+'.pdf') as pdf:
      f, axarr = plt.subplots(2, sharex=True)
      att1 = {'color': 'black', 'markerfacecolor': None, 'markersize': 2.5, 
      'markeredgewidth': 0.5, 'alpha': 1.0, 'marker': 'o', 
      'markeredgecolor': 'black','linestyle' : ':'} 
      att2 = {'color': 'blue', 'markerfacecolor': None, 'markersize': 2.5, 
      'markeredgewidth': 0.5, 'alpha': 1.0, 'marker': 'o', 
      'markeredgecolor': 'blue','linestyle' : 'None'} 
      axarr[0].plot(ai_plot,**att1)
      axarr[0].plot(ff_plot,**att2)
      axarr[0].set_title('Difference = '+str(chiSq))
      axarr[1].plot(sqDiff,'r')
      plt.ylabel('ERRORS')
      plt.xlabel('index')
      pdf.savefig()  # saves the current figure into a pdf page
      plt.close()
  return chiSq

# This is the fitabinitio.f version of errors
#def chiSq(ai_vals,ff_vals,ai_s2,genplot,filename):
#  genplot = bool(genplot)
#  sqDiff = [] 
#  ai_plot = []
#  ff_plot = []
#  for i in range(np.shape(ai_vals)[-1]):  
#    numerator = 0.0
#    denominator = 0.0
#    ai_val = 0.0
#    ff_val = 0.0
#    for j,k in zip(ai_vals,ff_vals):
#      numerator += ((j[i]-k[i])**2)
#      denominator += (k[i])**2
#      if genplot:
#	ai_val += (j[i])**2
#	ff_val += (k[i])**2
#    sqDiff.append(numerator/denominator)
#    if genplot:
#      ai_plot.append(ai_val)
#      ff_plot.append(ff_val)
#  sqDiff = np.array(sqDiff)
#  if genplot:
#    ai_plot = np.sqrt(ai_plot)
#    ff_plot = np.sqrt(ff_plot)
#  chiSq = np.sum(sqDiff)/len(sqDiff)
#  if genplot:
#    with PdfPages(filename+'.pdf') as pdf:
#      f, axarr = plt.subplots(2, sharex=True)
#      att1 = {'color': 'black', 'markerfacecolor': None, 'markersize': 2.5, 
#      'markeredgewidth': 0.5, 'alpha': 1.0, 'marker': 'o', 
#      'markeredgecolor': 'black','linestyle' : ':'} 
#      att2 = {'color': 'blue', 'markerfacecolor': None, 'markersize': 2.5, 
#      'markeredgewidth': 0.5, 'alpha': 1.0, 'marker': 'o', 
#      'markeredgecolor': 'blue','linestyle' : 'None'} 
#      axarr[0].plot(ai_plot,**att1)
#      axarr[0].plot(ff_plot,**att2)
#      axarr[0].set_title('Difference = '+str(chiSq))
#      axarr[1].plot(sqDiff,'r')
#      plt.ylabel('ERRORS')
#      plt.xlabel('index')
#      pdf.savefig()  # saves the current figure into a pdf page
#      plt.close()
#  return chiSq


def mkdir_p(path):
  try:
    os.makedirs(path)
  except OSError as exc: # Python >2.5
    if exc.errno == errno.EEXIST and os.path.isdir(path):
      pass
    else: raise

# These are the bounds for BH
class MyBounds(object):
  def __init__(self, xmax, xmin ):
      self.xmax = np.array(xmax)
      self.xmin = np.array(xmin)
  def __call__(self, **kwargs):
      x = kwargs["x_new"]
      tmax = bool(np.all(x <= self.xmax))
      tmin = bool(np.all(x >= self.xmin))
      if not tmax and tmin:
	outfile = open('OUTPUT','a')
	outfile.write('Values out of bounds!\n')
	outfile.close()
      return tmax and tmin

# Routine used to write a restart file for accepted parameter sets from BH
class WriteRestart(object):
  def __init__(self,nvars,nconst,zerosAndones,nmin,nmax,steps,filename):
    self.nvars = nvars
    self.nconst = nconst
    self.zerosAndones = zerosAndones
    self.nmax = nmax
    self.nmin = nmin
    self.steps = steps
    self.filename = str(filename)
  def __call__(self,x,f,accepted):
    if int(accepted) == 1:
      x = np.array(x)
      with open(self.filename, "w") as file:
	fmt="{0:.7f}"
	file.write('# The total chi sq is: '+fmt.format(f)+'\n')
	for lineNumber,var in enumerate(self.nvars):
	  output = str(var)+'\t'+fmt.format((np.concatenate((self.nconst,x),axis=0))[lineNumber])+'\t'+ \
	  str(self.zerosAndones[lineNumber])+'\t'+fmt.format(self.nmin[lineNumber])+'\t'+fmt.format(self.nmax[lineNumber])+'\t' + \
	  fmt.format(self.steps[lineNumber])+'\n'
	  file.write(output)

# this routine defines the magnitude of the steps in BH - these steps are defined in PARAMS
class MyTakeStep(object):
    def __init__(self, stepsizes):
        self.stepsizes = stepsizes
    def __call__(self, x):
	for i in range(len(self.stepsizes)):
	  s = self.stepsizes
	  x[i] += np.random.uniform(-s[i], s[i])
	  return x

# This is the objective function evaluated by the minimization algorithms 
class sumOfChi(object):
  def __init__(self,const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,ai_forces_s2,ai_dipoles_s2,ai_stresses_s2,
  factorF,factorD,factorS,plot):
    self.const_vars = const_vars
    self.pot_vars = pot_vars
    self.const_values = const_values
    self.factorF = factorF
    self.factorD = factorD
    self.factorS = factorS
    self.plot = bool(plot)
    # arrays with forces, dipoles and stresses
    # x = 0, y = 1, z = 2
    # xx = 0,xy = 1, yy = 2 , xz = 3, zz = 4, yz = 5
    self.ai_forces = ai_forces
    self.ai_dipoles = ai_dipoles
    self.ai_stresses = ai_stresses
    self.ai_forces_s2 = ai_forces_s2
    self.ai_dipoles_s2 = ai_dipoles_s2
    self.ai_stresses_s2 = ai_stresses_s2
  def __call__(self,test_values):
    # test_values should be an np array

    templates = readFromFile('TEMPLATES',2,True)
    for line in templates:
      replaceValues(line[0],line[1],self.const_vars+self.pot_vars,np.concatenate((self.const_values,test_values),axis=0))

    os.system('COMMANDS')
    with open('ERRORS', "r") as f:
      errors = int(f.readline().strip())
    if errors == 0: 
      ff_Fx,ff_Fy,ff_Fz = np.loadtxt('FF_FORCES',unpack=True)
      ff_forces = np.array([ff_Fx,ff_Fy,ff_Fz])
      ff_Dx,ff_Dy,ff_Dz = np.loadtxt('FF_DIPOLES',unpack=True)
      ff_dipoles = np.array([ff_Dx,ff_Dy,ff_Dz])
      index,ff_xx_xy,ff_yy_xz,ff_zz_yz = np.loadtxt('FF_STRESSES',unpack=True)
      ff_xx = (ff_xx_xy[0::2])
      ff_xy = (ff_xx_xy[1::2])
      ff_yy = (ff_yy_xz[0::2])
      ff_xz = (ff_yy_xz[1::2])
      ff_zz = (ff_zz_yz[0::2])
      ff_yz = (ff_zz_yz[1::2])
      ff_stresses = np.array([ff_xx,ff_yy,ff_zz,ff_xy,ff_xz,ff_yz])
      chiSqF = chiSq(self.ai_forces,ff_forces,self.ai_forces_s2,self.plot,'forces-errors')
      chiSqD = chiSq(self.ai_dipoles,ff_dipoles,self.ai_dipoles_s2,self.plot,'dipoles-errors')
      chiSqS = chiSq(self.ai_stresses,ff_stresses,self.ai_stresses_s2,self.plot,'stresses-errors')
      factorTot = self.factorF+self.factorD+self.factorS
      totalChi = (self.factorF*chiSqF+self.factorD*chiSqD+self.factorS*chiSqS)/factorTot
      outfile = open('OUTPUT','a')
      outfile.write('Forces chi sq: '+fmt.format(chiSqF)+'\n')
      outfile.write('Dipoles chi sq: '+fmt.format(chiSqD)+'\n')
      outfile.write('Stresses chi sq: '+fmt.format(chiSqS)+'\n')
      outfile.write('Total chi sq (no factors): '+fmt.format(np.mean([chiSqF,chiSqD,chiSqS]))+'\n')
      outfile.write('Total chi sq: '+fmt.format(totalChi)+'\n')
      outfile.write('\n')
      outfile.close()
    else: 
      totalChi = 1E10
      outfile.write('Error: likely due to unphysical parameter value\n') 
      outfile.close()
    return totalChi

###########################
# The program begins here!#
###########################
try:
    params = readFromFile('PARAMS',6,True)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
    print "No PARAMS file!"
try:
    forces_files = readFromFile('AI_FORCES_files',2,True)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
    print "No AI_FORCES_files file!"
try:
    dipoles_files = readFromFile('AI_DIPOLES_files',2,True)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
    print "No AI_DIPOLES_files file!"
try:
    stresses_files = readFromFile('AI_STRESSES_files',2,True)
except IOError as e:
    print "I/O error({0}): {1}".format(e.errno, e.strerror)
    print "No AI_STRESSES_files file!"
# Create an output file
outfile = open('OUTPUT','w')

fmt="{0:.7f}"

ai_Fx = np.empty(0)
ai_Fy = np.empty(0)
ai_Fz = np.empty(0)
for line in forces_files:
  dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  ai_Fx = np.append(ai_Fx,dummy1[:int(line[1])])
  ai_Fy = np.append(ai_Fy,dummy2[:int(line[1])])
  ai_Fz = np.append(ai_Fz,dummy3[:int(line[1])])
ai_forces = np.array([ai_Fx,ai_Fy,ai_Fz])
ai_Fx_s2 = np.var(ai_Fx)
ai_Fy_s2 = np.var(ai_Fy)
ai_Fz_s2 = np.var(ai_Fz)
ai_forces_s2 = np.array([ai_Fx_s2,ai_Fy_s2,ai_Fz_s2])

ai_Dx = np.empty(0)
ai_Dy = np.empty(0)
ai_Dz = np.empty(0)
for line in dipoles_files:
  dummy0, dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  ai_Dx = np.append(ai_Dx,dummy1[:int(line[1])])
  ai_Dy = np.append(ai_Dy,dummy2[:int(line[1])])
  ai_Dz = np.append(ai_Dz,dummy3[:int(line[1])])
ai_dipoles = np.array([ai_Dx,ai_Dy,ai_Dz])
ai_Dx_s2 = np.var(ai_Dx)
ai_Dy_s2 = np.var(ai_Dy)
ai_Dz_s2 = np.var(ai_Dz)
ai_dipoles_s2 = np.array([ai_Dx_s2,ai_Dy_s2,ai_Dz_s2])

ai_xx_xy = np.empty(0)
ai_yy_xz = np.empty(0)
ai_zz_yz = np.empty(0)
for line in stresses_files:
  dummy1, dummy2, dummy3 = np.loadtxt(line[0],unpack=True)
  if not int(line[1]) == 0:
    ai_xx_xy = np.append(ai_xx_xy,dummy1)
    ai_yy_xz = np.append(ai_yy_xz,dummy2)
    ai_zz_yz = np.append(ai_zz_yz,dummy3)
ai_xx = (ai_xx_xy[0::2])
ai_xy = (ai_xx_xy[1::2])
ai_yy = (ai_yy_xz[0::2])
ai_xz = (ai_yy_xz[1::2])
ai_zz = (ai_zz_yz[0::2])
ai_yz = (ai_zz_yz[1::2])
ai_stresses = np.array([ai_xx,ai_yy,ai_zz,ai_xy,ai_xz,ai_yz])
ai_xx_s2 = np.var(ai_xx)
ai_yy_s2 = np.var(ai_yy)
ai_zz_s2 = np.var(ai_zz)
ai_xy_s2 = np.var(ai_xy)
ai_xz_s2 = np.var(ai_xz)
ai_yz_s2 = np.var(ai_yz)
ai_diag_s2 = np.mean([ai_xx_s2,ai_yy_s2,ai_zz_s2])
ai_offd_s2 = np.mean([ai_xy_s2,ai_xz_s2,ai_yz_s2])
ai_stresses_s2 = np.array([ai_diag_s2,ai_diag_s2,ai_diag_s2,ai_offd_s2,ai_offd_s2,ai_offd_s2])


pot_vars = []
const_vars = []
#
pot_values = [] 
const_values = [] 
#
pot_values_min = [] 
pot_values_max = [] 
minim_bounds = [] 
const_pot_values_min = [] 
const_pot_values_max = [] 
#
step_sizes = []
const_step_sizes = []
to_fit_and_not0 = []
to_fit_and_not1 = []
for i in params:
  if not int(i[2]) == 0:
    pot_vars.append(i[0])
    pot_values.append(float(i[1]))
    pot_values_min.append(float(i[3]))
    pot_values_max.append(float(i[4]))
    minim_bounds.append(tuple([float(i[3]),float(i[4])]))
    step_sizes.append(float(i[5]))
    to_fit_and_not1.append(i[2])
  elif int(i[2]) == 0:
    const_vars.append(i[0])
    const_values.append(float(i[1]))
    const_pot_values_min.append(float(i[3]))
    const_pot_values_max.append(float(i[4]))
    const_step_sizes.append(float(i[5]))
    to_fit_and_not0.append(i[2])

pot_values = np.asarray(pot_values)
const_values = np.asarray(const_values)
tot_vars = const_vars+pot_vars
tot_values_min = const_pot_values_min+pot_values_min
tot_values_max = const_pot_values_max+pot_values_max
all_step_sizes = const_step_sizes+step_sizes
to_fit_and_not = to_fit_and_not0 + to_fit_and_not1

### Read parameters for the optimization routines
opt_file = readFromFile('OPT',2,True)
run_opts = {}
for i in opt_file:
  if str(i[0]) in ('method_Min','method_BH'):
    run_opts[i[0]] = i[1]
  elif i[0] == 'disp':
    run_opts[i[0]] = bool(i[1])
  elif i[0] in ('maxiter_Min','maxiter_BH','niter_success','niter_BH'):
    run_opts[i[0]] = np.int(i[1])
  else:
    run_opts[i[0]] = np.float(i[1])
factorF = run_opts['scalingF']
factorD = run_opts['scalingD']
factorS = run_opts['scalingS']
calc_order =  int(run_opts['calc_order'])
method_Min = run_opts['method_Min']
ftol_Min = run_opts['ftol_Min']
gtol_Min = run_opts['gtol_Min']
xtol_Min = run_opts['xtol_Min']
maxiter_Min = run_opts['maxiter_Min'] 
stepsize_Min = run_opts['stepsize_Min'] 
verbose = run_opts['disp'] 
tempScale = run_opts['temperature']
method_BH = run_opts['method_BH'] 
ftol_BH = run_opts['ftol_BH']
gtol_BH = run_opts['gtol_BH']
xtol_BH = run_opts['xtol_BH']
maxiter_BH = run_opts['maxiter_BH'] 
stepsize_BH = run_opts['stepsize_BH'] 
timestep = run_opts['timestep'] 
niter_BH = run_opts['niter_BH'] 
niter_success = run_opts['niter_success']

firstSumOfChi = sumOfChi(const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,ai_forces_s2,ai_dipoles_s2,ai_stresses_s2,
factorF,factorD,factorS,True)
firstSumOfChi(pot_values)
mkdir_p('./initial-errors-pdfs')
os.system('mv *.pdf ./initial-errors-pdfs')

thisSumOfChi = sumOfChi(const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,ai_forces_s2,ai_dipoles_s2,ai_stresses_s2,
factorF,factorD,factorS,False)
thisSumOfChi(pot_values)
# Minimization part 
if method_Min == 'L-BFGS-B':
  options={'ftol': ftol_Min, 'gtol':gtol_Min,'disp': verbose,'maxiter': maxiter_Min,'eps':stepsize_Min}
elif method_Min == 'CG':
  options={'gtol':gtol_Min,'disp': verbose,'maxiter': maxiter_Min,'eps':stepsize_Min}
elif method_Min == 'Nelder-Mead':
  options={'ftol': ftol_Min, 'xtol':xtol_Min,'disp': verbose,'maxiter': maxiter_Min}
else:
  sys.exit('Minimization method '+method_Min+' not supported')
# Choose the calculation order
if calc_order == 0: 
  if method_Min == 'L-BFGS-B':
    bounds = minim_bounds
    results_Min = minimize(thisSumOfChi,pot_values,method=method_Min,bounds=bounds,
		  options=options)
  elif method_Min == 'CG':
    results_Min = minimize(thisSumOfChi,pot_values,method=method_Min,tol=ftol_Min,
		  options=options)
  else:
    results_Min = minimize(thisSumOfChi,pot_values,method=method_Min,
		  options=options)
  outfile = open('OUTPUT','a')
  outfile.write(results_Min.message)
  outfile.close()
  tot_values = np.concatenate((const_values,results_Min.x),axis=0)

  # Write a results file 
  write_Results_Min = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESULTS_Min')
  write_Results_Min(results_Min.x,results_Min.fun,accepted=1)

  secondSumOfChi = sumOfChi(const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,ai_forces_s2,ai_dipoles_s2,ai_stresses_s2,
  factorF,factorD,factorS,True)
  secondSumOfChi(results_Min.x)
  mkdir_p('./min-errors-pdfs')
  os.system('mv *.pdf ./min-errors-pdfs')
########################################################################################
# basin hopping part using the minimization parameters as a starting guess             #
# The temperature should be a fraction of the final function value from the minimizer  #
########################################################################################
# Define variables for BH RESTART file 
write_restart = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESTART')
#
if calc_order == 0:
  # Pass the optimized values to BH
  pot_values = results_Min.x
  # Temperature parameter for BH
  temperature = results_Min.fun*tempScale
elif calc_order == 1:
  # Temperature parameter for BH
  temperature = thisSumOfChi(pot_values)*tempScale
# Step sizes for BH
mysteps = MyTakeStep(step_sizes) 
outfile = open('OUTPUT','a')
outfile.write('The temperature is set to: '+str(temperature)+'\n')
outfile.close()
# Set the options for the minimization algo in BH
if method_BH in ('L-BFGS-B','CG'):
  options={'ftol': ftol_BH, 'gtol':gtol_BH,'disp': verbose,'maxiter': maxiter_BH,'eps':stepsize_BH}
elif method_BH == 'Nelder-Mead':
  options={'ftol': ftol_BH, 'xtol':xtol_BH,'disp': verbose,'maxiter': maxiter_BH}
else:
  sys.exit('Minimization method '+method_BH+' not supported')
# Bounds for BH
mybounds = MyBounds(pot_values_max,pot_values_min)
if method_BH in ('L-BFGS-B'):
  # Bounds for minimization method inside BH
  bounds = minim_bounds
  minimizer_kwargs = {'method': method_BH,'bounds':bounds,'options':options}
else:
  minimizer_kwargs = {'method': method_BH,'options':options}
results_BH = basinhopping(thisSumOfChi,pot_values,T=temperature,stepsize=timestep,take_step=mysteps,
	  minimizer_kwargs=minimizer_kwargs,
	  disp=verbose,accept_test=mybounds,
	  niter=niter_BH,callback=write_restart,niter_success=niter_success)
outfile = open('OUTPUT','a')
outfile.write(results_BH.message)
outfile.close()
tot_values = np.concatenate((const_values,results_BH.x),axis=0)
#
## Write a results file for the BH part 
write_Results_BH = WriteRestart(tot_vars,const_values,to_fit_and_not,tot_values_min,tot_values_max,all_step_sizes,'RESULTS_BH')
write_Results_BH(results_BH.x,results_BH.fun,accepted=1)

finalSumOfChi = sumOfChi(const_vars,pot_vars,const_values,ai_forces,ai_dipoles,ai_stresses,ai_forces_s2,ai_dipoles_s2,ai_stresses_s2,
factorF,factorD,factorS,True)
finalSumOfChi(results_BH.x)
mkdir_p('./BH-errors-pdfs')
os.system('mv *.pdf ./BH-errors-pdfs')
# close the output file
outfile.close()
